"use strict";(self.webpackChunkaquarius_docs=self.webpackChunkaquarius_docs||[]).push([[70],{9138:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>h,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"device-editor/finite-element-mesh/mesh-generation","title":"Mesh Generation","description":"Overview","source":"@site/docs/device-editor/finite-element-mesh/mesh-generation.md","sourceDirName":"device-editor/finite-element-mesh","slug":"/device-editor/finite-element-mesh/mesh-generation","permalink":"/aquarius-docs/device-editor/finite-element-mesh/mesh-generation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"Meshing Grid","permalink":"/aquarius-docs/device-editor/finite-element-mesh/meshing-grid"},"next":{"title":"Circuit Simulator","permalink":"/aquarius-docs/category/circuit-simulator"}}');var s=n(4848),r=n(8453),d=n(9030);const o={sidebar_position:2},h="Mesh Generation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Usage Instructions",id:"usage-instructions",level:2},{value:"Parameters",id:"parameters",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"mesh-generation",children:"Mesh Generation"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"Once the initial meshing grid has been defined, this command will generate the nodes at the intersections of those lines and triangulate them to form the finite element mesh. The Delaunay algorithm is used and additional checks are made to ensure optimal triangle shapes, reducing narrow or poorly shaped elements that can impact simulation accuracy."}),"\n",(0,s.jsx)(i.h2,{id:"usage-instructions",children:"Usage Instructions"}),"\n",(0,s.jsx)(i.p,{children:"Before creating a finite element device model, it is important to ensure that at least one region is defined and a suitable meshing grid has been specified."}),"\n",(0,s.jsx)(i.p,{children:"To generate a finite element model:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"From the Menu, select Mesh -> Generate Finite Element Mesh Model. This will open the mesh properties dialog."}),"\n"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:(0,d.Ay)("img/device-editor/finite-element-mesh/mesh-generation/01.png"),width:"800"})}),"\n",(0,s.jsxs)(i.ol,{start:"2",children:["\n",(0,s.jsx)(i.li,{children:"If automatic mesh refinement is required, enable the Mesh Refinement Options checkbox. By default, this option is disabled. When enabled, you can adjust the mesh refinement settings as needed."}),"\n"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:(0,d.Ay)("img/device-editor/finite-element-mesh/mesh-generation/02.png"),width:"600"})}),"\n",(0,s.jsxs)(i.ol,{start:"3",children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Once you are satisfied with the settings, click ",(0,s.jsx)(i.code,{children:"OK"})," to generate the mesh."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Depending on the complexity of the device model and the meshing grid, the generation process may take some time. The progress of the mesh generation will be displayed in the status window in the centre of the screen. Once complete, the finished FE model will be displayed. The P and N regions of the device will also be plotted, highlighting the position of the metallurgical junction, which is the point where the net doping concentration is zero Atoms/cm\xb3."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:(0,d.Ay)("img/device-editor/finite-element-mesh/mesh-generation/03.png"),width:"800"})}),"\n",(0,s.jsx)(i.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)("div",{class:"properties-table",children:(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Name"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Unit"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Number of Iterations"})}),(0,s.jsx)(i.td,{children:"Used to specify the number of refinement cycles."}),(0,s.jsx)(i.td,{children:"-"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Refinement Variable"})}),(0,s.jsx)(i.td,{children:"Used to specify the physical property used for refinement. Options: [Net Doping]"}),(0,s.jsx)(i.td,{children:"-"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Measure as Signed-Log10"})}),(0,s.jsx)(i.td,{children:"When checked, the refinement variable is measured on a logarithmic scale with sign."}),(0,s.jsx)(i.td,{children:"-"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Comparison Type"})}),(0,s.jsx)(i.td,{children:"Used to define the method for comparing refinement values. Options: [Difference, Percentage Difference]"}),(0,s.jsx)(i.td,{children:"-"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Refinement Threshold"})}),(0,s.jsx)(i.td,{children:"Used to set the threshold value for refinement."}),(0,s.jsx)(i.td,{children:"-"})]})]})]})})]})}function m(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>o});var t=n(6540);const s={},r=t.createContext(s);function d(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);